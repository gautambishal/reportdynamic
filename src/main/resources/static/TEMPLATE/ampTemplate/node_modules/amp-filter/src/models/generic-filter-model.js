var _ = require('underscore');

var BaseFilterModel = require('../models/base-filter-model');
var TreeNodeModel = require('../tree/tree-node-model');


module.exports = BaseFilterModel.extend({

  initialize:function(options) {
    BaseFilterModel.prototype.initialize.apply(this, [options]);
    this.set('modelType', 'TREE');
    this.getTree(); // starts getTree calls
  },

  // load tree if needed, else return what we already have..
  getTree: function() {
    var self = this;
    var loaded = this.get('_loaded');

    if (!loaded) {
      self.set('_loaded', this._createTree().then(function() {

        // trickle up numSelected.
    	  if(self.get('tree')!= undefined){
        self.get('tree').on('change:numSelected', function(model, value) {
          self.set('numSelected', value);
          self.set('numPossible', self.get('tree').get('numPossible'));
        });
    	  }
        return self.get('tree');
      }));
      
    }

    return this.get('_loaded');
  },

  getNumSelected: function(){
    var numSelected = this.get('numSelected');
    // if none selected, or all selected, treat the same.
    if (!numSelected || this.get('numSelected') === this.get('numPossible')) {
      return 0;
    } else {
      return numSelected;
    }
  },

  serialize: function(options) {
    var tree = this.get('tree');
    if (!tree) {
      //console.warn('no tree found', this.attributes);
      return {}; //no tree, nothing to serialize.
    } else {
      var tmpAry = tree.serialize(options);
      return tmpAry;
    }
  },

  deserialize: function(listOfSelected) {
    var self = this;
    var tree = this.get('tree');
    if (listOfSelected) {
      if (!tree) {
        console.warn('deserialize no tree found', self);
        return false; //no tree, nothing to serialize.
      } else {
        tree.deserialize(listOfSelected);
      }
    }
  },

  reset: function() {
    var tree = this.get('tree');
    if (tree) {
      // TODO: add a third type for semi-filled
      // force trigger, because otherwise nodes that are 'half-filled' but false won't refresh.
      tree.set('selected', true);
      tree.set('selected', false);

    }
  },

  _createTree: function() {
    if (!this.url) {
      this.url = this.get('endpoint');
    }

    return this.fetch({
      type: this.get('method'),
      data:'{}'
    })
    .fail(function(jqXHR, textStatus, errorThrown) {
      console.error('failed to get filter ', jqXHR, textStatus, errorThrown);
    });
  },

  parse: function(data) {
    var self = this;    

    //if it's an obj, jam it into an array first, helps solve inconsistancy in API format.
    if (!_.isArray(data)) {
      data = [data];
    }

    if (_.isArray(data) && data.length > 0) {
      var rootNodeObj = null;
      // Builds tree of views from returned data
      // If data is a single element, just make it the root..
      
      /* TODO-CONSTANTIN: temporary comment until I finish learning Filters frontend
      console.log("iterating " + data.length + " elems...");
      _.each(data, function(elem) {
    	  console.log("\tname = " + elem.name + ", id = " + elem.id);
      });
      */
      if (data.length === 1) {
    	if(data[0].filterId && !data[0].name) {
          data[0].name =  data[0].filterId;
        }
        if(data[0].values){
          data[0].children =  data[0].values;
        }

        data[0].isSelectable = false;
        
        //data[0].filterName = data[0].displayName;

        rootNodeObj = data[0];

      } else {
        rootNodeObj = {
          id: -1,
          code: '-1',
          name: self.get('name'),
          children: data,
          selected: undefined,
          expanded: false,
          isSelectable: false,
          createUnkowns: true/*,
          filterName: self.get('displayName')*/
        };
      }

      var treeModel = new TreeNodeModel(rootNodeObj);
      self.set('tree', treeModel);
    }

    return;
  }

});

